# Curso de ECMAScript: Historia y Versiones de JavaScript

## Historia de JavaScript

- **1950**: En esta década, se desarrollaron las primeras computadoras electrónicas de gran escala, como la UNIVAC I y la ENIAC. Estas máquinas ocupaban grandes espacios y tenían capacidades de procesamiento limitadas.

- **1970**: En esta década, se creó ARPANET, la precursora de Internet. ARPANET fue una red de computadoras desarrollada por el Departamento de Defensa de los Estados Unidos. Fue la primera red en utilizar el protocolo de comunicación TCP/IP, sentando las bases para la comunicación en red a nivel mundial.

- **1990**: En esta década, Tim Berners-Lee ideó el hipertexto para crear la World Wide Web (www), una nueva forma de interactuar con Internet. También creó las bases del protocolo de transmisión HTTP, el lenguaje de documentos HTML y el concepto de los URL.

- **1993**: En este año, se lanzó el primer navegador web popular, llamado Mosaic. Fue desarrollado por el National Center for Supercomputing Applications (NCSA) y permitió a los usuarios acceder y navegar por páginas web de manera más fácil e intuitiva. Mosaic allanó el camino para la popularización de Internet y la World Wide Web.

## Browser Wars

La guerra de navegadores, también conocida como "Browser Wars", fue una competencia intensa entre diferentes navegadores web en la década de 1990 y principios de la década de 2000. Durante este período, varios navegadores lucharon por la dominancia en el mercado, introduciendo nuevas características y tecnologías para atraer a los usuarios. La historia de la guerra de navegadores comienza en 1993, cuando se lanzaron los primeros navegadores web. Netscape Navigator fue uno de los primeros navegadores populares y desempeñó un papel importante en el inicio de la guerra de navegadores. Netscape fue pionero en muchas características y tecnologías web, como JavaScript y las hojas de estilo en cascada (CSS). En respuesta al éxito de Netscape, Microsoft lanzó Internet Explorer en 1995. Internet Explorer se convirtió en un competidor fuerte y comenzó a ganar cuota de mercado rápidamente. Microsoft aprovechó su posición dominante en el mercado de sistemas operativos Windows para incluir Internet Explorer de forma predeterminada en sus sistemas operativos, lo que llevó a un aumento significativo en su adopción. La guerra de navegadores se intensificó con la aparición de nuevas versiones de Netscape Navigator y Internet Explorer, cada una tratando de superar a la otra en términos de velocidad, características y compatibilidad con los estándares web. Ambos navegadores introdujeron tecnologías propietarias y no estándar, lo que llevó a problemas de compatibilidad entre los sitios web. En 1998, Netscape decidió liberar el código fuente de su navegador bajo el nombre de Mozilla. Esto llevó a la creación de la Fundación Mozilla y al desarrollo del navegador Mozilla Firefox, que se convirtió en un competidor importante en la guerra de navegadores. La guerra de navegadores llegó a su punto máximo a principios de la década de 2000, cuando Internet Explorer alcanzó una cuota de mercado dominante. Sin embargo, a medida que pasaba el tiempo, surgieron nuevos competidores, como Google Chrome y Safari, que desafiaron la posición de Internet Explorer. Google Chrome, lanzado en 2008, se convirtió rápidamente en uno de los navegadores más populares debido a su velocidad y simplicidad. Chrome también introdujo un nuevo modelo de actualización automática, lo que permitió a los usuarios tener siempre la última versión del navegador. A medida que los navegadores continuaron evolucionando, se hizo más importante para los desarrolladores web asegurarse de que sus sitios fueran compatibles con múltiples navegadores. Los estándares web, como HTML, CSS y JavaScript, se volvieron más importantes para garantizar la compatibilidad entre los navegadores. En la actualidad, la guerra de navegadores ha evolucionado hacia una competencia más equilibrada, con varios navegadores populares que ofrecen características y rendimiento similares. Los estándares web se han vuelto más sólidos y los desarrolladores web se esfuerzan por crear sitios compatibles con múltiples navegadores.

En resumen, la guerra de navegadores fue una competencia intensa entre diferentes navegadores web en la década de 1990 y principios de la década de 2000. Netscape Navigator, Internet Explorer, Mozilla Firefox, Google Chrome y Safari fueron algunos de los navegadores más destacados en esta batalla por la dominancia en el mercado. A medida que los estándares web se fortalecieron y los usuarios se volvieron más exigentes, la competencia se centró en ofrecer características, rendimiento y compatibilidad con los estándares web.

### Que es ECMAScript

ECMAScript es un estándar que define el lenguaje de programación JavaScript. Fue creado para estandarizar las características y el comportamiento del lenguaje en diferentes implementaciones. ECMAScript se basa en el lenguaje JavaScript desarrollado por Netscape.

La primera versión de ECMAScript, conocida como ECMAScript 1, fue lanzada en junio de 1997. Esta versión estableció las bases del lenguaje y definió su sintaxis básica.

A medida que JavaScript se volvió más popular y se utilizó en una amplia variedad de aplicaciones, se lanzaron nuevas versiones de ECMAScript para agregar características y funcionalidades adicionales.

- **ECMAScript 3** (diciembre de 1999): Esta versión introdujo mejoras significativas en el lenguaje, como soporte para expresiones regulares, manejo de excepciones y mejoras en el manejo de cadenas de texto.

- **ECMAScript 5** (diciembre de 2009): Esta versión trajo consigo características importantes, como el modo estricto ("strict mode"), que permite escribir código más seguro y eficiente, así como métodos adicionales para manipular arreglos y objetos.

- **ECMAScript 6** (junio de 2015): También conocido como ECMAScript 2015, esta versión fue una de las actualizaciones más significativas de ECMAScript. Introdujo características como las clases, los módulos, las promesas y el operador de propagación, entre otros. ECMAScript 6 marcó un gran avance en la evolución de JavaScript y permitió a los desarrolladores escribir código más limpio y modular.

- **ECMAScript 2016** (junio de 2016): Esta versión introdujo características como el operador de exponenciación y el operador de encadenamiento opcional.

- **ECMAScript 2017** (junio de 2017): Esta versión agregó características como las funciones asíncronas y las palabras clave async y await, que facilitan la escritura de código asincrónico.

- **ECMAScript 2018** (junio de 2018): Esta versión incluyó características como las expresiones regulares con lookbehind y lookahead positivos y negativos, así como mejoras en los objetos literales.

- **ECMAScript 2019** (junio de 2019): Esta versión agregó características como los operadores de propagación en objetos y las funciones Array.prototype.flat() y Array.prototype.flatMap().

- **ECMAScript 2020** (junio de 2020): Esta versión introdujo características como el operador de encadenamiento nulo (??), el operador de encadenamiento opcional (?.) y las funciones BigInt para trabajar con números enteros de precisión arbitraria.

- **ECMAScript 2021** (junio de 2021): Esta versión agregó características como los operadores lógicos encadenados (||= y ??=), el método String.prototype.replaceAll() y mejoras en las expresiones regulares.

## Que es el TC39

El TC39 es el Comité Técnico de Ecma International encargado de la estandarización y evolución del lenguaje de programación JavaScript, también conocido como ECMAScript. El nombre "TC39" proviene del número de comité técnico asignado por Ecma International.

El TC39 está compuesto por desarrolladores de JavaScript, implementadores, académicos y otros expertos en el lenguaje. Su objetivo principal es mantener y evolucionar la definición de JavaScript, incluyendo la sintaxis del lenguaje, la semántica y las bibliotecas y tecnologías complementarias que lo respaldan.

El comité TC39 trabaja en estrecha colaboración con la comunidad de JavaScript y recibe contribuciones de esta comunidad. Esto incluye comentarios y sugerencias sobre propuestas existentes, así como nuevas propuestas para mejorar el lenguaje.

El proceso de estandarización de ECMAScript sigue un conjunto de etapas definidas por el TC39. Estas etapas van desde la propuesta inicial hasta la adopción final como parte del estándar ECMAScript. Cada propuesta pasa por un proceso de revisión y discusión en el comité antes de avanzar a la siguiente etapa.

El TC39 ha sido fundamental para el desarrollo y la evolución de JavaScript a lo largo de los años. Ha introducido nuevas características y mejoras en cada versión de ECMAScript, lo que ha permitido a los desarrolladores aprovechar al máximo el lenguaje y crear aplicaciones web más potentes y eficientes.

El proceso de estandarización de ECMAScript sigue cinco etapas reguladas por el TC39:

- **Stage 0 (Strawperson)**: En esta etapa, se presenta una idea inicial para una adición o cambio en la especificación de ECMAScript. No hay requisitos de entrada específicos para esta etapa, y la propuesta se encuentra en una fase temprana de desarrollo.

- **Stage 1 (Proposal)**: En esta etapa, se presenta una propuesta formal que describe un problema y sugiere una solución adecuada. La propuesta debe tener un campeón, alguien que se haga responsable de su desarrollo y avance. También se deben identificar los posibles desafíos y se espera recibir comentarios de la comunidad y del comité.

- **Stage 2 (Draft)**: En esta etapa, la propuesta se convierte en un borrador más detallado que describe la sintaxis y la semántica utilizando un lenguaje de especificación formal. También se espera que la propuesta tenga pruebas de aceptación y se realicen implementaciones experimentales.

- **State 3 (Candidate)**: En esta etapa, la propuesta se considera un candidato y se espera que se realicen refinamientos adicionales basados en los comentarios de las implementaciones y los usuarios. En esta etapa, se espera que la propuesta sea lo suficientemente estable y madura para su inclusión en la especificación formal de ECMAScript.

- **Stage 4 (Finished)**: Esta es la última etapa, en la que se considera que la propuesta está lista para su inclusión en la especificación formal de ECMAScript. En esta etapa, se espera que la propuesta esté completamente especificada y se entregue con la próxima edición de ECMAScript.

## ES6

ECMAScript 6, también conocido como ES6 o ES2015, es una versión importante del estándar ECMAScript que se lanzó en junio de 2015. Introdujo numerosas características y mejoras al lenguaje JavaScript, lo que permitió a los desarrolladores escribir código más limpio, legible y eficiente. A continuación, se detallan algunas de las características clave de ECMAScript 6:

### Declaración de Variables

ES6 introdujo nuevas formas de declarar variables utilizando las palabras clave let y const. let permite declarar variables con alcance de bloque, mientras que const se utiliza para declarar variables inmutables.

```js
let x = 5;
const PI = 3.14159;
```

### Arrow Functions

Las arrow functions, o funciones flecha, son una forma más concisa de escribir funciones en JavaScript. Proporcionan una sintaxis más corta y clara, y tienen un comportamiento especial en cuanto al valor de this.

```js
// Función tradicional
function sum(a, b) {
  return a + b;
}

// Arrow function
const sum = (a, b) => a + b;
```

### Clases

ES6 introdujo la sintaxis de clases en JavaScript, lo que facilita la creación de objetos y la implementación de la herencia. Las clases proporcionan una forma más orientada a objetos de trabajar en JavaScript.

```js
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

const rectangle = new Rectangle(5, 10);
console.log(rectangle.getArea()); // Output: 50
```

#### Get y Set

Estos son métodos especiales que se utilizan para acceder y modificar propiedades de una clase de una manera controlada. El método **get** se utiliza para obtener el valor de una propiedad, mientras que el método **set** se utiliza para establecer o modificar el valor de una propiedad.

```js
class Rectangle {
  constructor(ancho, altura) {
    this.ancho = ancho;
    this.altura = altura;
  }

  get area() {
    return this.ancho * this.altura;
  }

  set ancho(nuevoAncho) {
    if (nuevoAncho > 0) {
      this.ancho = nuevoAncho;
    } else {
      console.log("El ancho debe ser mayor que cero.");
    }
  }
}

const rectangle = new Rectangle(5, 10);
console.log(rectangle.area); // Imprime: 50

rectangle.ancho = 8;
console.log(rectangle.area); // Imprime: 80

rectangle.ancho = -2; // Imprime: "El ancho debe ser mayor que cero."
```

La clase **Rectangle** tiene una propiedad **this.ancho** y un método **get** llamado **area** que calcula y devuelve el área del rectángulo. También tiene un método **set** llamado **ancho** que establece el valor de la propiedad **this.ancho**, pero solo si el nuevo ancho es mayor que cero.

Al crear una instancia de la clase **Rectangle** y acceder a la propiedad **area**, se llama automáticamente al método **get** y se devuelve el resultado del cálculo del área. Al establecer el valor de la propiedad **this.ancho**, se llama automáticamente al método **set** y se verifica si el nuevo ancho es válido.

### Template Literals

Los template literals permiten la creación de cadenas de texto más legibles y flexibles. Se definen utilizando comillas invertidas (`) en lugar de comillas simples o dobles, y permiten la interpolación de variables y expresiones dentro de la cadena.

```js
const name = "John";
const age = 30;

const message = `My name is ${name} and I am ${age} years old.`;
console.log(message); // Output: My name is John and I am 30 years old.
```

### Desestructuración

La desestructuración es una característica que permite extraer valores de objetos o arreglos en variables individuales de forma más concisa. Esto simplifica el proceso de asignación de valores a variables.

```js
const person = {
  name: "John",
  age: 30,
  city: "New York",
};

const { name, age, city } = person;
console.log(name, age, city); // Output: John 30 New York
```

### Spreed Operator

El operador de propagación (...) permite expandir elementos de un arreglo o propiedades de un objeto en lugares donde se esperan múltiples elementos o argumentos. Esto facilita la manipulación de arreglos y objetos de manera más flexible.

```js
const numbers = [1, 2, 3];
const sum = (a, b, c) => a + b + c;

console.log(sum(...numbers)); // Output: 6
```

### Parámetros por defecto

Las funciones con parámetros por defecto permiten crear funciones más flexibles y que se pueden emplear en distintas circunstancias, lo que hace que el código sea más mantenible y legible.

```js
const greet = (name = "John") => console.log(`Hello, ${name}!`);

greet(); // Salida: Hello, John!
greet("Alice"); // Salida: Hello, Alice!
```

### Módulos

ES6 introdujo un sistema de módulos nativo en JavaScript, lo que permite organizar y reutilizar el código de manera más modular. Los módulos proporcionan una forma estándar de exportar e importar funciones, variables y clases entre diferentes archivos.

Archivo math.js:

```js
export const sum = (a, b) => a + b;
export const subtract = (a, b) => a - b;
```

Archivo main.js:

```js
import { sum, subtract } from "./math.js";

console.log(sum(5, 3)); // Output: 8
console.log(subtract(10, 4)); // Output: 6
```

### Promesas

Las promesas en JavaScript son una forma de manejar operaciones asíncronas de manera más elegante y práctica que utilizando funciones de callback directamente. Una promesa representa una operación que aún no se ha completado y puede tener dos resultados
posibles: se cumple (resolve) o se rechaza (reject).

```js
const fetchData = () =>
  new Promise((resolve, reject) => {
    // Simulación de una operación asíncrona
    setTimeout(() => {
      const success = true; // Cambia esto a false para simular un error
      if (success) {
        resolve("¡La promesa se cumplió!"); // La promesa se cumple
      } else {
        reject("¡La promesa fue rechazada!"); // La promesa es rechazada
      }
    }, 2000); // Espera 2 segundos antes de resolver o rechazar la promesa
  });

// Usando la promesa
fetchData()
  .then((mensaje) => {
    console.log(mensaje); // La promesa se cumplió
  })
  .catch((error) => {
    console.error(error); // La promesa fue rechazada
  });
```

La función fetchData devuelve una promesa que se resuelve después de 2 segundos. Dentro de la promesa, se puede realizar una operación asíncrona, como una solicitud HTTP, y luego se utiliza el método resolve para cumplir la promesa con los datos obtenidos o el método reject para rechazar la promesa con un error.

Luego, se utiliza el método then para manejar el resultado de la promesa cuando se cumple y el método catch para manejar cualquier error que ocurra durante la ejecución de la promesa.

Las promesas nos permiten escribir un código más limpio y claro al manejar operaciones asíncronas, evitando el anidamiento excesivo de callbacks y facilitando el control de flujos de datos asíncronos en una aplicación.

### Generator

Un generador en ES6 es una función especial que permite pausar y reanudar su ejecución en diferentes puntos. A diferencia de una función regular, que se ejecuta de principio a fin y devuelve un valor, un generador puede detenerse en medio de su ejecución y luego continuar desde donde se detuvo.

La sintaxis para definir un generador en ES6 es utilizando la palabra clave function\*. Aquí tienes un ejemplo básico de cómo se ve la definición de un generador:

```js
function* myGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const generador = myGenerator();

console.log(generador.next()); // { value: 1, done: false }
console.log(generador.next()); // { value: 2, done: false }
console.log(generador.next()); // { value: 3, done: false }
console.log(generador.next()); // { value: undefined, done: true }
```

En este ejemplo, hemos definido un generador llamado **myGenerator** que utiliza la sintaxis function\*. Dentro del generador, utilizamos la palabra clave **yield** para pausar la ejecución y devolver un valor. Cada vez que llamamos al método **next()** en el generador, se reanuda la ejecución y se devuelve el siguiente valor **yielded**. El objeto devuelto por **next()** tiene una propiedad value que contiene el valor **yielded** y una propiedad done que indica si el generador ha terminado de generar valores.

En el ejemplo, llamamos al método **next()** cuatro veces, lo que nos permite obtener los valores **1, 2** y **3** que fueron **yielded** por el generador. En la cuarta llamada a **next()**, el generador ha terminado de generar valores y devuelve **{ value: undefined, done: true }**.

Los generadores son útiles cuando necesitamos generar una secuencia de valores de manera controlada y pausada. Podemos utilizarlos para iterar sobre grandes conjuntos de datos, generar secuencias infinitas o implementar algoritmos de búsqueda y exploración.

### Set-Add

El objeto **set** en ES6 es una estructura de datos que permite crear una colección de valores únicos. A diferencia de los arrays, los sets no permiten duplicados, lo que significa que cada valor en un **set** es único.

```js
const miSet = new Set();
miSet.add(1);
miSet.add(2);
miSet.add(3);
```

Hemos creado un set vacío llamado miSet y luego hemos agregado los valores 1, 2 y 3 utilizando el método add().

Los sets también proporcionan métodos para verificar si un valor existe en el set (has()), eliminar un valor del set (delete()), obtener el tamaño del set (size), y más.

```js
const miSet = new Set();
miSet.add(1);
miSet.add(2);
miSet.add(3);

console.log(miSet.has(2)); // true
console.log(miSet.size); // 3

miSet.delete(2);
console.log(miSet.has(2)); // false
console.log(miSet.size); // 2
```

Utilizamos el método **has()** para verificar si el valor **2** existe en el set. Luego, utilizamos el método **size** para obtener el tamaño del set. Después, utilizamos el método **delete()** para eliminar el valor **2** del set. Finalmente, volvemos a verificar si el valor **2** existe en el set y obtenemos el nuevo tamaño del set.

Los sets son útiles cuando necesitamos almacenar una colección de valores únicos y realizar operaciones como verificación de existencia, eliminación y obtención del tamaño de manera eficiente.

## ES7

### Exponentiation operator

El operador de **exponenciación** (\*\*) permite calcular la potencia de un número de manera más concisa. Antes de su introducción, se utilizaba el método **Math.pow()** para realizar este cálculo.

```js
console.log(2 ** 3); // Resultado: 8
console.log(4 ** 0.5); // Resultado: 2
```

### Array includes

El método **includes()** es un método agregado al prototipo de los arrays en ES7. Permite verificar si un elemento específico está presente en un array. Aquí tienes un ejemplo de cómo se utiliza el método **includes()**:

```js
const array = [1, 2, 3, 4, 5];
console.log(array.includes(3)); // Resultado: true
console.log(array.includes(6)); // Resultado: false
```

Utilizamos el método **includes()** para verificar si el número 3 está presente en el array. El método devuelve true si el elemento está presente y false si no lo está.

El uso del operador de **exponenciación** y el método **includes()** proporciona una sintaxis más clara y concisa para realizar cálculos de potencia y verificar la presencia de elementos en un array, respectivamente.

### Object entries

El método **Object.entries()** es una característica introducida en ES7 (ECMAScript 2016) que permite obtener un array de pares clave-valor de las propiedades enumerables de un objeto. Cada par clave-valor se representa como un array de dos elementos: la clave y el valor correspondiente.

```js
const objeto = { a: 1, b: 2, c: 3 };
const entradas = Object.entries(objeto);

console.log(entradas);
// Resultado: [["a", 1], ["b", 2], ["c", 3]]
```

En este ejemplo, tenemos un objeto llamado objeto con tres propiedades: a, b y c. Utilizamos el método **Object.entries()** para obtener un array de pares clave-valor de las propiedades enumerables del objeto. El resultado es un array que contiene tres arrays, cada uno representando un par clave-valor.

### Object values

El método **Object.values()** es una característica introducida en ES7 (ECMAScript 2016) que permite obtener un array de los valores de las propiedades enumerables de un objeto. Este método devuelve un array que contiene los valores de las propiedades del objeto en el mismo orden en que se encuentran en el objeto.

```js
const objeto = { a: 1, b: 2, c: 3 };
const valores = Object.values(objeto);

console.log(valores);
// Resultado: [1, 2, 3]
```

Tenemos un objeto llamado **objeto** con tres propiedades: **a, b** y **c**. Utilizamos el método **Object.values()** para obtener un array de los valores de las propiedades enumerables del objeto. El resultado es un array que contiene los valores **1, 2** y **3**, en el mismo orden en que se encuentran en el objeto.

El método **Object.values()** es útil cuando necesitamos acceder a los valores de las propiedades de un objeto sin tener que iterar sobre las claves. Podemos utilizar este método para realizar operaciones en los valores del objeto, como sumarlos, filtrarlos o realizar cualquier otra manipulación necesaria.

## ES8

### String padding

El "string padding" se refiere a la acción de agregar caracteres adicionales a un string para alcanzar una longitud específica. Esto es útil cuando se necesita formatear o alinear cadenas de texto, como en la creación de tablas o en la presentación de datos de manera uniforme.

En ES7, se introdujeron dos métodos para realizar el "string padding": **padStart()** y **padEnd()**. Estos métodos permiten agregar caracteres al inicio o al final de un string hasta que alcance una longitud determinada.

El método **padStart()** agrega caracteres al inicio de un string hasta que alcance la longitud especificada.

```js
const texto = "Hola";
const textoPad = texto.padStart(10, "x");

console.log(textoPad);
// Resultado: 'xxxxxxHola'
```

Utilizamos el método **padStart()** para agregar cinco caracteres 'x' al inicio del string 'Hola' hasta que alcance una longitud de 10 caracteres.

El método **padEnd()** funciona de manera similar, pero agrega caracteres al final del string.

```js
const texto = "Hola";
const textoPad = texto.padEnd(10, "x");

console.log(textoPad);
// Resultado: 'Holaxxxxxx'
```

Utilizamos el método **padEnd()** para agregar cinco caracteres 'x' al final del string 'Hola' hasta que alcance una longitud de 10 caracteres.

### Funciones asíncronas

Las funciones asíncronas en JavaScript son una forma de escribir código asincrónico de manera más legible y estructurada. Permiten diferir la ejecución de una función hasta que se complete una operación asíncrona, como una solicitud de red o una lectura de archivo, sin bloquear la ejecución del programa.

La sintaxis de una función asíncrona se define utilizando la palabra clave **async** antes de la declaración de la función. Dentro de una función asíncrona, se pueden utilizar las palabras clave **await** para esperar la resolución de una Promesa antes de continuar con la ejecución del código.

```js
const getInfo = async () => {
  const respuesta = await fetch("https://api.example.com/data");
  const datos = await respuesta.json();
  return datos;
};
```

La función **getInfo()** es una función asíncrona que utiliza await para esperar la respuesta de una solicitud de red realizada con **fetch()**. Luego, se utiliza **await** nuevamente para esperar la conversión de la respuesta a formato JSON utilizando el método **json()**. Finalmente, se devuelve el resultado obtenido.

Al llamar a una función asíncrona, se devuelve una Promesa que se puede manejar utilizando los métodos **then()** y **catch()** para obtener los resultados o manejar los errores.

```js
getInfo()
  .then((datos) => {
    console.log(datos);
  })
  .catch((error) => {
    console.error(error);
  });
```

Se llama a la función **getInfo()** y se utiliza el método **then()** para obtener los datos devueltos por la Promesa. Si ocurre algún error, se maneja utilizando el método **catch()**.

Las funciones asíncronas simplifican la escritura de código asincrónico al permitirnos utilizar una sintaxis más similar a la programación síncrona. Esto hace que el código sea más legible y más fácil de mantener.

## ES9

### Expresiones regulares

Las expresiones regulares en JavaScript son patrones utilizados para buscar y manipular texto en cadenas de caracteres. Se componen de caracteres literales y metacaracteres que tienen significados especiales. Los metacaracteres permiten definir reglas y condiciones más complejas que las simples coincidencias de texto.

En JavaScript, las expresiones regulares son objetos y se pueden utilizar con varios métodos, como **exec(), test(), match(), replace(), search() y split()**, para buscar, reemplazar y manipular texto.

```js
const texto = "Hola, mi número de teléfono es 123-456-7890";
const patron = /\d{3}-\d{3}-\d{4}/;
const resultado = texto.match(patron);

console.log(resultado);
// Resultado: ["123-456-7890"]
```

Utilizamos la expresión regular **\d{3}-\d{3}-\d{4}** para buscar un número de teléfono en el texto. El método **match(**) devuelve un array con la coincidencia encontrada.

Las expresiones regulares pueden ser muy poderosas y flexibles para buscar y manipular texto de manera eficiente. Sin embargo, también pueden ser complicadas de entender y construir correctamente. Es recomendable estudiar y practicar su uso para aprovechar al máximo su potencial.

### Finally

El método **finally()** en las Promesas de JavaScript se utiliza para programar una función que se ejecutará sin importar si la Promesa se resuelve o se rechaza. Esta función se ejecutará una vez que la Promesa esté "asentada" (settled), es decir, cuando se haya cumplido o rechazado.

La sintaxis básica para utilizar **finally()** en una Promesa es la siguiente:

```js
promesa.finally(funcion);
```

Donde promesa es una instancia de una Promesa y funcion es la función que se ejecutará en el bloque finally.

```js
const promesa = new Promise((resolve, reject) => {
  // Simulamos una operación asíncrona
  setTimeout(() => {
    const success = true;
    if (success) {
      resolve("La promesa se resolvió exitosamente");
    } else {
      reject("La promesa fue rechazada");
    }
  }, 2000);
});

promesa
  .then((resultado) => {
    console.log(resultado);
  })
  .catch((error) => {
    console.error(error);
  })
  .finally(() => {
    console.log("La promesa ha sido asentada");
  });
```

Creamos una Promesa que se resuelve después de 2 segundos. Utilizamos **then()** para manejar el resultado exitoso de la Promesa y **catch()** para manejar el caso en que la Promesa sea rechazada. Luego, utilizamos **finally()** para programar una función que se ejecutará sin importar el resultado de la Promesa. En este caso, simplemente mostramos un mensaje en la consola.

Es importante tener en cuenta que **finally()** devuelve una nueva Promesa que se resuelve con el mismo valor o razón que la Promesa original. Esto significa que puedes encadenar llamadas a otros métodos de Promesa después de **finally()**.

## ES10

### FlatMap

El método **flatMap()** en JavaScript se utiliza en arrays para aplicar una función a cada elemento del array y luego aplanar el resultado en un nuevo array. A diferencia del método **map()**, que devuelve un nuevo array con los resultados de aplicar una función a cada elemento, **flatMap()** permite trabajar con arrays anidados y automáticamente aplana el resultado en un solo nivel.

```js
const array = [1, 2, 3, 4];
const resultado = array.flatMap((elemento) => [elemento * 2]);

console.log(resultado);
// Resultado: [2, 4, 6, 8]
```

Utilizamos **flatMap()** para aplicar la función elemento => [elemento * 2] a cada elemento del array. La función multiplica cada elemento por 2 y devuelve un nuevo array con el resultado. El método **flatMap()** aplanará automáticamente el resultado en un solo nivel.

Es importante tener en cuenta que **flatMap()** elimina automáticamente los elementos undefined y los niveles de anidamiento adicionales en el resultado. Esto puede ser útil cuando se trabaja con arrays que contienen arrays anidados.

### Flat

El método **flat()** en JavaScript se utiliza en arrays para aplanar un array multidimensional en un solo nivel. Esto significa que toma un array que contiene otros arrays y los combina en un solo array.

```js
const array = [1, 2, [3, 4], [5, [6, 7]]];
const resultado = array.flat();

console.log(resultado);
// Resultado: [1, 2, 3, 4, 5, [6, 7]]
```

El array array contiene elementos simples y otros arrays anidados. Utilizamos **flat()** para aplanar el array en un solo nivel. El resultado es un nuevo array que contiene todos los elementos del array original, incluidos los elementos de los arrays anidados.

Es importante tener en cuenta que **flat()** elimina automáticamente los elementos undefined y los niveles de anidamiento adicionales en el resultado. Si se desea aplanar completamente un array multidimensional sin importar la profundidad de anidamiento, se puede utilizar flat(Infinity).

### TrimStart y TrimEnd

Los métodos **trimStart()** y **trimEnd()** en JavaScript se utilizan para eliminar los espacios en blanco del principio y del final de una cadena de caracteres, respectivamente.

El método **trimStart()** elimina los espacios en blanco del principio de una cadena, mientras que el método **trimEnd()** elimina los espacios en blanco del final de una cadena.

```js
const texto = "   Hola, mundo!   ";
const textoSinEspaciosInicio = texto.trimStart();
const textoSinEspaciosFinal = texto.trimEnd();

console.log(textoSinEspaciosInicio);
// Resultado: 'Hola, mundo!   '

console.log(textoSinEspaciosFinal);
// Resultado: '   Hola, mundo!'
```

La variable texto contiene una cadena con espacios en blanco al principio y al final. Utilizamos los métodos **trimStart()** y **trimEnd()** para eliminar los espacios en blanco del principio y del final de la cadena, respectivamente. Los resultados se asignan a las variables textoSinEspaciosInicio y textoSinEspaciosFinal.

Es importante tener en cuenta que los métodos **trimStart()** y **trimEnd()** no modifican la cadena original, sino que devuelven una nueva cadena con los espacios en blanco eliminados. Esto se debe a que las cadenas en JavaScript son inmutables.

Estos métodos son útiles cuando se trabaja con cadenas de texto que pueden contener espacios en blanco innecesarios al principio o al final. Al eliminar estos espacios en blanco, se puede garantizar una manipulación y comparación más precisa de las cadenas.

### try / catch

La estructura **try...catch** en JavaScript se utiliza para manejar errores y excepciones en el código. Permite ejecutar un bloque de código en el bloque **try** y capturar cualquier error que ocurra en el bloque **catch**, evitando que el error detenga la ejecución del programa.

```js
try {
  // Bloque de código a probar
} catch (error) {
  // Bloque de código para manejar el error
}
```

Dentro del bloque **try**, se coloca el código que se desea probar en busca de errores. Si ocurre un error durante la ejecución de este bloque, se lanza una excepción y el control se transfiere al bloque catch. El objeto **error** captura la información del error, como el mensaje de error y otros detalles relevantes.

```js
try {
  const resultado = 10 / 0; // Genera un error de división por cero
  console.log(resultado); // Esta línea no se ejecutará
} catch (error) {
  console.error("Se produjo un error:", error.message);
}
```

Intentamos realizar una división por cero en el bloque **try**, lo cual genera un error. El control se transfiere al bloque catch, donde capturamos el error y mostramos un mensaje de error en la consola.

El bloque catch es opcional en la estructura **try...catch**. Si no se proporciona un bloque catch, el error se propagará hacia arriba en la pila de llamadas hasta que se encuentre un bloque catch que pueda manejarlo.

Es importante tener en cuenta que el uso de **try...catch** debe ser selectivo y se recomienda utilizarlo solo para capturar y manejar errores específicos. También es importante tener en cuenta que el bloque catch solo capturará errores que ocurran dentro del bloque **try**. Si ocurre un error fuera del bloque **try**, no será capturado por el catch.

### FromEntries

El método **fromEntries()** en JavaScript se utiliza para convertir una lista de pares clave-valor en un objeto. Toma una estructura iterable, como un array o un objeto Map, y devuelve un nuevo objeto cuyas propiedades son los pares clave-valor de la estructura iterable.

```js
const array = [
  ["a", 1],
  ["b", 2],
  ["c", 3],
];
const objeto = Object.fromEntries(array);

console.log(objeto);
// Resultado: { a: 1, b: 2, c: 3 }
```

Tenemos un array array que contiene pares clave-valor. Utilizamos **fromEntries()** para convertir este array en un objeto. El resultado es un nuevo objeto con propiedades correspondientes a los pares clave-valor del array.

Es importante tener en cuenta que **fromEntries()** solo funciona en navegadores modernos y no es compatible con versiones antiguas de Internet Explorer. Si se necesita utilizar **fromEntries()** en navegadores más antiguos, se puede utilizar un polyfill o una implementación alternativa.

El método **fromEntries()** es útil cuando se trabaja con estructuras de datos que contienen pares clave-valor y se desea convertirlos en un objeto. Esto puede ser útil, por ejemplo, al procesar datos recibidos de una API o al manipular datos en un formato específico.

## ES11

### Optional chaining

El optional chaining es un operador introducido en JavaScript a partir de ES2020 que permite acceder de manera segura a propiedades o métodos anidados sin tener que verificar manualmente si cada propiedad existe. Esto ayuda a simplificar el código y reduce la probabilidad de errores debido a valores indefinidos.

El operador de optional chaining se representa con el símbolo **?.** y puede aparecer en tres posiciones diferentes:

- obj?.prop: acceso opcional a una propiedad estática.
- obj?.[expr]: acceso opcional a una propiedad dinámica.
- func?.(...args): llamada opcional a una función o método.

Cuando se utiliza el optional chaining, si el operando del lado izquierdo del **?.** es **undefined** o **null**, el lado derecho no se evaluará y la expresión devolverá **undefined**. De lo contrario, se realizará el acceso a la propiedad, el método o la llamada a la función de manera normal.

El optional chaining se combina bien con el operador de fusión nula (**??**) para proporcionar valores de respaldo en caso de que la propiedad o el método no existan.

```js
const person = {
  name: "Juan",
  age: 30,
  address: {
    street: "Calle Principal",
    city: "Ciudad Ejemplo",
    country: "País Ejemplo",
  },
};

// Acceso seguro a propiedades anidadas
const name = person?.name; // 'Juan'
const ciudad = person?.address?.city; // 'Ciudad Ejemplo'
const postalCode = person?.address?.postalCode; // undefined

console.log(name);
console.log(city);
console.log(postalCode);
```

Tenemos un objeto **person** con propiedades anidadas. Utilizando el optional chaining (**?.**), podemos acceder de manera segura a estas propiedades sin preocuparnos por si alguna de ellas es **undefined** o **null**. Si la propiedad existe, se accede a su valor normalmente. Si la propiedad no existe, la expresión devuelve **undefined**.

### BigInt y Nullish

#### BigInt

El tipo de dato **BigInt** es un objeto incorporado en JavaScript que se utiliza para representar números enteros más grandes que el límite máximo del tipo de dato Number, que es 2^53 - 1. Los valores **BigInt** pueden ser extremadamente grandes y no están sujetos a la limitación de precisión de los números de tipo Number.

Para crear un valor **BigInt**, se utiliza la función **BigInt()** y se le pasa como argumento un número o una cadena que representa el número entero deseado.

```js
const numero = BigInt(123456789); // Crear un valor BigInt a partir de un número
const cadena = BigInt("987654321"); // Crear un valor BigInt a partir de una cadena
```

Es importante tener en cuenta que los valores **BigInt** y los valores **Number** son tipos de datos diferentes en JavaScript. Por lo tanto, al compararlos, el operador de identidad **(===)** devolverá **false** incluso si los valores son iguales. Sin embargo, el operador de igualdad **(==)** devolverá **true** si los valores son iguales, aunque sean de tipos diferentes.

El tipo de dato **BigInt** admite operadores aritméticos y lógicos similares a los del tipo Number. Sin embargo, hay algunas diferencias y consideraciones a tener en cuenta al trabajar con **BigInt**. Por ejemplo, no se permite la aritmética entre un **BigInt** y un **Number**, ya que la conversión de tipos puede perder información.

#### Nullish

El operador de Nullish Coalescing (**??**) es un operador introducido en JavaScript que se utiliza para evaluar y devolver un valor de respaldo si el valor de una expresión es **null** o **undefined**. A diferencia del operador lógico OR (**||**), que también puede devolver un valor de respaldo si la expresión es falsa, el operador de Nullish Coalescing solo devuelve el valor de respaldo si la expresión es **null** o **undefined**, y no si es cualquier otro valor falsy como 0 o una cadena vacía **""**.

```js
const valor1 = null;
const valor2 = undefined;
const valor3 = 0;

const resultado1 = valor1 ?? "Valor de respaldo"; // "Valor de respaldo"
const resultado2 = valor2 ?? "Valor de respaldo"; // "Valor de respaldo"
const resultado3 = valor3 ?? "Valor de respaldo"; // 0

console.log(resultado1);
console.log(resultado2);
console.log(resultado3);
```

El operador de Nullish Coalescing se utiliza para proporcionar un valor de respaldo en caso de que las variables **valor1** y **valor2** sean **null** o **undefined**. Sin embargo, en el caso de la variable **valor3**, que tiene un valor falsy (**0**), el operador de Nullish Coalescing no devuelve el valor de respaldo, ya que **0** no es **null** ni **undefined**.

### AllSettled

El método **Promise.allSettled()** es una función incorporada en JavaScript que toma un iterable de promesas como argumento y devuelve una promesa que se cumple cuando todas las promesas del iterable se han resuelto, es decir, ya sea cumplidas o rechazadas.

A diferencia del método Promise.all(), que se cumple solo si todas las promesas se resuelven correctamente y se rechaza si alguna de ellas es rechazada, **Promise.allSettled()** espera a que todas las promesas se resuelvan o se rechacen antes de devolver un resultado. El resultado es un array que contiene objetos con el estado y el valor o la razón de cada promesa.

```js
const promesa1 = Promise.resolve(33);
const promesa2 = new Promise((resolve) => setTimeout(() => resolve(66), 0));
const promesa3 = 99;
const promesa4 = Promise.reject(new Error("un error"));

Promise.allSettled([promesa1, promesa2, promesa3, promesa4]).then(
  (resultados) => {
    console.log(resultados);
  }
);
```

tenemos cuatro promesas: **promesa1**, **promesa2**, **promesa3** y **promesa4**. Utilizamos **Promise.allSettled()** para esperar a que todas las promesas se resuelvan o se rechacen. El resultado se maneja en el **then()** y se muestra en la consola. El resultado es un array que contiene objetos con las propiedades **status** (que puede ser "fulfilled" o "rejected") y **value** o **reason** (que contiene el valor resuelto o la razón del rechazo).

### GlobalThis

**globalThis** es una característica introducida en JavaScript que proporciona una forma estandarizada de acceder al objeto global en diferentes entornos, como navegadores y entornos de servidor como Node.js. Antes de la introducción de **globalThis**, acceder al objeto global en diferentes entornos requería el uso de diferentes variables globales, como window en navegadores y global en Node.js. Esto dificultaba la escritura de código portátil que funcionara en múltiples entornos.

Con **globalThis**, puedes acceder al objeto global de manera consistente sin importar el entorno en el que te encuentres. La sintaxis para acceder a **globalThis** es simplemente **globalThis**. En un navegador, **globalThis** es equivalente a **window**, mientras que en Node.js puede ser **global** o **self**. La propiedad **globalThis** está definida en la especificación de ECMAScript y está disponible en todas las versiones modernas de JavaScript, incluyendo las versiones más recientes de ECMAScript.

```js
console.log(globalThis);
```

El resultado de **console.log(globalThis)** variará según el entorno en el que se ejecute el código. En un navegador, mostrará el objeto **Window**, en Node.js mostrará el objeto **global**, y en un entorno de Web Worker mostrará el objeto **DedicatedWorkerGlobalScope**.

### MatchAll

El método **matchAll()** es un método incorporado en JavaScript que se utiliza en las cadenas de texto para encontrar todas las coincidencias de una expresión regular. A diferencia del método **match()**, que solo encuentra la primera coincidencia, **matchAll()** devuelve un iterador que contiene todas las coincidencias encontradas en la cadena.

```js
cadena.matchAll(expresionRegular);
```

Donde **cadena** es la cadena de texto en la que se realizará la búsqueda y expresionRegular es la expresión regular que se utilizará para encontrar las coincidencias.

El resultado de **matchAll()** es un iterador que contiene objetos de coincidencia. Cada objeto de coincidencia tiene las siguientes propiedades:

- **value**: La cadena de texto que coincide con la expresión regular.
- **index**: La posición en la cadena de texto donde comienza la coincidencia.
- **input**: La cadena de texto original en la que se realizó la búsqueda.
- **groups**: Un objeto que contiene las coincidencias de los grupos de captura si se utilizan en la expresión regular.

```js
const regularPhrase = /\b(Hola)+\b/g; // Expresión regular para encontrar la palabra "Hola"

const text = "Hola, soy un ejemplo de cadena de texto.";

for (const match of text.matchAll(regularPhrase)) {
  console.log(match);
}
```

### Dynamic Import

El dynamic import es una característica introducida en ECMAScript 2020 que permite importar módulos de forma dinámica en JavaScript. A diferencia del import estático, que se realiza en tiempo de compilación, el dynamic import se realiza en tiempo de ejecución, lo que significa que el módulo se carga y se ejecuta solo cuando es necesario.

```js
import("route/to/module")
  .then((modulo) => {
    // Hacer algo con el módulo importado
  })
  .catch((error) => {
    // Manejar cualquier error de importación
  });
```

En lugar de utilizar la declaración **import** estática en la parte superior del archivo, el **dynamic import** se realiza utilizando la función **import()**. Esta función devuelve una promesa que se resuelve con el módulo importado. Puedes utilizar el método **then()** para acceder al módulo y realizar acciones con él. También puedes utilizar el método **catch()** para manejar cualquier error de importación.

El **dynamic import** es útil en situaciones en las que no se necesita cargar un módulo de forma inmediata, sino que se desea cargarlo bajo demanda, como en casos de carga diferida o carga condicional de módulos. Esto puede ser especialmente útil en aplicaciones web grandes donde se desea optimizar el rendimiento y reducir el tiempo de carga inicial.

```js
const button = document.querySelector("#myButton");

button.addEventListener("click", () => {
  import("./myModule.js")
    .then((module) => {
      module.myFunction();
    })
    .catch((error) => {
      console.log("Error importing the module:", error);
    });
});
```

## ES12

### Numeric separator

El **numeric separator** es una característica introducida en ECMAScript 2021 que permite separar los dígitos de un número utilizando guiones bajos (\_) para mejorar la legibilidad del código. Esta característica es especialmente útil cuando se trabaja con números grandes, ya que facilita la comprensión de la magnitud del número al separar los dígitos en grupos más pequeños.

```js
const population = 1_000_000_000;
console.log(population); // 1000000000

const distance = 299_792_458; // Velocidad de la luz en metros por segundo
console.log(distance); // 299792458

const pi = 3.141_592_653_589_793;
console.log(pi); // 3.141592653589793
```

Utilizamos el **numeric separator** para separar los dígitos en grupos más pequeños en los números **population**, **distance** y **pi**. Esto hace que los números sean más legibles y fáciles de entender.

Es importante tener en cuenta que los guiones bajos (\_) no afectan el valor numérico del número, simplemente se utilizan para mejorar la legibilidad del código. Además, hay algunas restricciones en el uso del **numeric separator**, como no poder colocar un guion bajo al principio o al final de un número, ni utilizar múltiples guiones bajos seguidos.

### ReplaceAll

El método **replaceAll()** es un método incorporado en JavaScript que se utiliza en las cadenas de texto para reemplazar todas las ocurrencias de una subcadena con una nueva subcadena. A diferencia del método replace(), que solo reemplaza la primera ocurrencia, **replaceAll()** reemplaza todas las ocurrencias encontradas en la cadena.

```js
const cadena = "Hola mundo, mundo maravilloso";
const nuevaCadena = cadena.replaceAll("mundo", "universo");
console.log(nuevaCadena); // "Hola universo, universo maravilloso"
```

Utilizamos replaceAll() para reemplazar todas las ocurrencias de la subcadena "mundo" en la cadena de texto por la subcadena "universo". El resultado es la nueva cadena "Hola universo, universo maravilloso".

### Promise-any

El método **Promise.any()** es un método estático introducido en ECMAScript 2021 que toma un iterable de promesas como entrada y devuelve una sola promesa. Esta promesa devuelta se cumple cuando cualquiera de las promesas del iterable se cumple, con el valor de cumplimiento de la primera promesa. Se rechaza cuando todas las promesas del iterable se rechazan.

```js
const p1 = new Promise((resolve, reject) =>
  setTimeout(resolve, 3000, "Promesa 1 cumplida")
);
const p2 = new Promise((resolve, reject) =>
  setTimeout(reject, 2000, "Promesa 2 rechazada")
);
const p3 = new Promise((resolve, reject) =>
  setTimeout(resolve, 1000, "Promesa 3 cumplida")
);

Promise.any([p1, p2, p3])
  .then((response) => console.log(response)) // "Promesa 3 cumplida"
  .catch((error) => console.log(error));
```

Creamos tres promesas (**p1, p2 y p3**) que se resuelven o se rechazan después de ciertos intervalos de tiempo. Utilizamos **Promise.any()** para esperar a que se cumpla cualquiera de las promesas. La promesa devuelta se cumple con el valor de cumplimiento de la primera promesa que se cumple, en este caso, "Promesa 3 cumplida". Si todas las promesas se rechazan, se captura el error.

Es importante tener en cuenta que **Promise.any()** devuelve una promesa que se cumple tan pronto como una de las promesas del iterable se cumple. Si todas las promesas se rechazan, se produce un error llamado **AggregateError** que contiene los motivos de rechazo de todas las promesas.

## ES13

### at

Este método proporciona una forma de acceder a los elementos de un array o string de una manera más intuitiva y flexible.

El método **at()** toma un índice como argumento y devuelve el elemento en ese índice. La característica única de este método es que también acepta índices negativos, que cuentan desde el final del array o string.

```js
let array = [1, 2, 3, 4, 5];
console.log(array.at(0)); // Devuelve 1
console.log(array.at(-1)); // Devuelve 5
```

**array.at(0)** devuelve el primer elemento del array, que es **1**. **array.at(-1)** devuelve el último elemento del array, que es **5**.

Este método es especialmente útil cuando quieres acceder a los últimos elementos de un array o string sin tener que calcular la longitud total.

### top level await en el consumo de una API

El operador await en JavaScript se utiliza para esperar a que se resuelva una Promise. Tradicionalmente, solo podía usarse dentro de una función async, lo que significa que si querías usar await, debías envolver tu código en una función async.

Sin embargo, ECMAScript introdujo una característica llamada "Top Level Await" que permite usar await en el nivel superior de un módulo, es decir, fuera de cualquier función async. Esto significa que un módulo puede comportarse como una función async, permitiendo que el código asincrónico se ejecute de manera más intuitiva y legible.

Un módulo que importa un módulo con "Top Level Await" esperará a que se cargue antes de evaluar su cuerpo. Esto es especialmente útil cuando se consume una API, ya que a menudo necesitas esperar a que se complete una solicitud de red antes de poder usar los datos que devuelve.

```js
// user.mjs
const response = await fetch("https://jsonplaceholder.typicode.com/users");
const users = await response.json();
export default users;

// app.mjs
import users from "./user.mjs";
console.log(users); // Imprime los datos de los usuarios
```

user.mjs hace una solicitud a una API para obtener datos de usuario y exporta los datos. app.mjs importa los datos de usuario y los imprime. Gracias al "Top Level Await", app.mjs esperará a que se complete la solicitud de la API antes de intentar imprimir los datos de usuario.

## Finalize este curso en 6h
